{"version":3,"file":"","sourceRoot":"","sources":["draw.js","getColor.js","index.js","ray.js","setupSettingsGui.js","sphere.js","vec.js"],"sourcesContent":["import { Vec } from './vec';\r\nimport { Ray } from './ray';\r\nexport function draw(ctx, scene, getColor, userSettings) {\r\n    const started = new Date().getTime();\r\n    clearCanvas(ctx, scene.dimu, scene.dimv);\r\n    // our camera\r\n    const origin = new Vec(0, 0, 0, 0);\r\n    // lower left corner of the viewport in camera coordinate system\r\n    const lowerLeft = new Vec(-1, -1, -1, 0);\r\n    // such that lowerLeft + vvec + vvec = new Vec(-lowerLeft.x, -lowerLeft.y, lowerLeft.z);\r\n    const uvec = new Vec(userSettings.uvecX, 0, 0, 0);\r\n    const vvec = new Vec(0, userSettings.vvecY, 0, 0);\r\n    for (let u = 0; u < scene.dimu; u += 1) {\r\n        for (let v = 0; v < scene.dimv; v += 1) {\r\n            const ur = u / scene.dimu; // [0;1)\r\n            const vr = v / scene.dimv; // [0;1)\r\n            // a ray from the camera to a pixel in the viewport\r\n            const tracedRay = new Ray(origin, lowerLeft.add(uvec.scale(ur), vvec.scale(vr)));\r\n            const color = getColor(scene, tracedRay);\r\n            //            if (u % 100 == 0 && v % 100 == 0)\r\n            //            {\r\n            //                console.log(u, v, color)\r\n            //            }\r\n            drawPixel(ctx, u, v, color);\r\n        }\r\n    }\r\n    console.log(`drawing done: ${new Date().getTime() - started} ms`);\r\n}\r\nfunction clearCanvas(ctx, dimu, dimv) {\r\n    ctx.clearRect(0, 0, dimu, dimv);\r\n    ctx.fillStyle = '#cccccc';\r\n    ctx.fillRect(0, 0, dimu, dimv);\r\n}\r\nfunction drawPixel(ctx, x, y, color) {\r\n    // ((x + y) / 256) * (256 - 255.99) > y\r\n    // (x + y) * 0.01/256 > y\r\n    // x > 255.99y\r\n    //\r\n    // 256 * 0.53517 => 137.00352\r\n    // 255.99 * 0.53517 => 136.9981683\r\n    // 120.001 / 256 => 0.46875390625\r\n    // 0.46875390625 * 255.99 => 119.996312460938\r\n    const fill = \"rgb(\" +\r\n        Math.floor(color.r * 255.99) + \",\" +\r\n        Math.floor(color.g * 255.99) + \",\" +\r\n        Math.floor(color.b * 255.99) + \")\";\r\n    ctx.fillStyle = fill;\r\n    //if (x % 10 === 0 && y % 10 === 0) {\r\n    //    console.log(JSON.stringify({ x, y, fill }));\r\n    //}\r\n    ctx.fillRect(x, y, 1, 1);\r\n}\r\n","import { Vec } from './vec';\r\nexport function getColor(scene, tracedRay) {\r\n    for (const obj of scene.objects) {\r\n        if (obj.isHit(tracedRay)) {\r\n            return new Vec(1, 0, 0, 0);\r\n        }\r\n    }\r\n    // background: hyperbolic gradient\r\n    // among all rays that hit the viewport at a given v', the one with the highest\r\n    // normalized abs(y) is the one with x = 0 (the one going directly towards the viewport)\r\n    // all vectors from the origin have the same non-normalized y (=v'), divided by a length\r\n    // >= sqrt(v'^2 + z^2), with equality only when x = 0\r\n    //\r\n    // imagine a cone with a vertex at the origin (i.e. rays with a given 'y') intersecting a\r\n    // plane (the viewport plane) - you get a hyperbola\r\n    //\r\n    // v' = y/sqrt(x^2 + y^2 + z'^2) (z' and v' are parameters)\r\n    // v'^2*z'^2 = y^2*(1-v'^2) - x^2 (which is a hyperbolic formula)\r\n    // y = +/- sqrt(param + x^2)/param => y has maximum abs when x = 0\r\n    //\r\n    // this is why the resulting gradient is dimmest in the middle and gets brighter at the sides\r\n    // (bottom half), or is brightest in the middle and dims towards the sides (top half)\r\n    // - points with equal lumosity are on a hyperbola with vertex in the vertical midline\r\n    // of the viewport\r\n    //\r\n    // among rays with x=0, the highest normalized y is the one hitting at the highest v, so\r\n    // the brightest place is the top center; analogously, the dimmest place is the bottom center\r\n    const unitDirection = tracedRay.direction.normalize();\r\n    const t = 0.5 * (unitDirection.y + 1);\r\n    const color = new Vec(0, 0, 0, 0).interpolate(new Vec(1, 1, 1, 0), t);\r\n    return color;\r\n    //    (square (abs(x - 0.5)))*sgn(x - 0.5) + 0.5 from 0 to 1\r\n    //    if (color.r > 0.3 && color.r < 0.31) {\r\n    //        return new Vec(1, 0, 0);\r\n    //    } else if (color.r > 0.7 && color.r < 0.71) {\r\n    //        return new Vec(0, 1, 0);\r\n    //    } else if (color.r > 0.49 && color.r < 0.51) {\r\n    //        return new Vec(1, 1, 1);\r\n    //    } else if (color.r > 0.8 && color.r < 0.81) {\r\n    //        return new Vec(0, 0, 1);\r\n    //    }\r\n    //    return new Vec();\r\n}\r\n","// %USER_BACK%\\btsync\\books\\cg\\Ray Tracing in a Weekend.pdf\r\nimport { getColor } from './getColor';\r\nimport { Vec } from './vec';\r\nimport { draw } from './draw';\r\nimport { Sphere } from './sphere';\r\nimport { setupSettingsGui } from './setupSettingsGui';\r\nconst getCenterSphere = (userSettings) => new Sphere(new Vec(0, 0, -1, 0), userSettings.radius);\r\nconst userSettings = {\r\n    uvecX: { name: \"X\", initial: 2, min: -4, max: 4, step: 0.1 },\r\n    vvecY: { name: \"Y\", initial: 2, min: -2, max: 2, step: 0.1 },\r\n    radius: { name: \"radius\", initial: 0.2, min: 0, max: 4, step: 0.1 },\r\n};\r\nconst getScene = userSettings => ({\r\n    dimu: 600,\r\n    dimv: 600,\r\n    objects: [getCenterSphere(userSettings)]\r\n});\r\nconst canvas = document.getElementById('canvas');\r\ncanvas.width = getScene(userSettings).dimu;\r\ncanvas.height = getScene(userSettings).dimv;\r\nconst ctx = canvas.getContext('2d');\r\nconst drawScene = () => draw(ctx, getScene(userSettings), getColor, userSettings);\r\nsetupSettingsGui(userSettings, drawScene);\r\ndrawScene();\r\n","export class Ray {\r\n    constructor(origin, direction) {\r\n        this._origin = origin;\r\n        this._direction = direction;\r\n    }\r\n    get origin() {\r\n        return this._origin;\r\n    }\r\n    get direction() {\r\n        return this._direction;\r\n    }\r\n    toString() {\r\n        return JSON.stringify({ o: this.origin + \"\", d: this.direction + \"\" }).replace(/\"/g, \"\");\r\n    }\r\n}\r\n","export function setupSettingsGui(userSettings, onChange) {\r\n    const gui = new dat.GUI();\r\n    for (const key of Object.keys(userSettings)) {\r\n        const userSetting = userSettings[key];\r\n        userSettings[key] = userSetting.initial;\r\n        const step = userSetting.step || (userSetting.max - userSetting.min / 100);\r\n        const newSetting = gui.add(userSettings, key, userSetting.min, userSetting.max)\r\n            .step(step)\r\n            .name(userSetting.name || key);\r\n        newSetting.onFinishChange(x => onChange);\r\n    }\r\n}\r\n","export class Sphere {\r\n    constructor(center, radius) {\r\n        this._center = center;\r\n        this._radius = radius;\r\n    }\r\n    get center() {\r\n        return this._center;\r\n    }\r\n    get radius() {\r\n        return this._radius;\r\n    }\r\n    get type() {\r\n        return \"sphere\";\r\n    }\r\n    isHit(tracedRay) {\r\n        const radius = this.radius;\r\n        const oc = tracedRay.origin.sub(this.center);\r\n        const a = tracedRay.direction.dot(tracedRay.direction);\r\n        const b = 2 * oc.dot(tracedRay.direction);\r\n        const c = oc.dot(oc) - this.radius * this.radius;\r\n        const disc = b * b - 4 * a * c;\r\n        return disc >= 0;\r\n    }\r\n}\r\n","export class Vec {\r\n    constructor(x, y, z, w) {\r\n        this._x = x;\r\n        this._y = y;\r\n        this._z = z;\r\n        this._w = w;\r\n    }\r\n    get x() {\r\n        return this._x;\r\n    }\r\n    get y() {\r\n        return this._y;\r\n    }\r\n    get z() {\r\n        return this._z;\r\n    }\r\n    get w() {\r\n        return this._w;\r\n    }\r\n    get r() {\r\n        return this._x;\r\n    }\r\n    get g() {\r\n        return this._y;\r\n    }\r\n    get b() {\r\n        return this._z;\r\n    }\r\n    get a() {\r\n        return this._w;\r\n    }\r\n    add(...args) {\r\n        let toReturn = this;\r\n        for (const v2 of args) {\r\n            toReturn = new Vec(toReturn.x + v2.x, toReturn.y + v2.y, toReturn.z + v2.z, toReturn.w + v2.w);\r\n        }\r\n        return toReturn;\r\n    }\r\n    scale(s) {\r\n        return new Vec(this.x * s, this.y * s, this.z * s, this.w * s);\r\n    }\r\n    sub(v2) {\r\n        return this.add(v2.neg());\r\n    }\r\n    neg() {\r\n        return this.scale(-1);\r\n        //    howMany = typeof howMany === \"undefined\" ? 4 : howMany;\r\n        //    return new Vec(\r\n        //        howMany > 0 ? -this.x : this.x,\r\n        //        howMany > 1 ? -this.y : this.y,\r\n        //        howMany > 2 ? -this.z : this.z,\r\n        //        howMany > 3 ? -this.w : this.w,\r\n        //        );\r\n    }\r\n    normalize() {\r\n        return this.scale(1 / this.length);\r\n    }\r\n    interpolate(v2, t) {\r\n        return this.scale(t).add(v2.scale(1 - t));\r\n    }\r\n    dot(v2) {\r\n        return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;\r\n    }\r\n    cross(v2) {\r\n        /*\r\n        yz - zy\r\n        -xz + zx\r\n        xy - yx\r\n        */\r\n        return new Vec(this.y * v2.z - this.z * v2.y, -this.x * v2.z + this.z * v2.x, this.x * v2.y - this.y * v2.x, this.w); // todo: 4d vector cross product\r\n    }\r\n    toString() {\r\n        return JSON.stringify([\r\n            this.x.toFixed(2),\r\n            this.y.toFixed(2),\r\n            this.z.toFixed(2),\r\n            this.w.toFixed(2)\r\n        ])\r\n            .replace(/\"/g, \"\");\r\n    }\r\n    get squaredLength() {\r\n        return Math.pow(this.x, 2) +\r\n            Math.pow(this.y, 2) +\r\n            Math.pow(this.z, 2) +\r\n            Math.pow(this.w, 2);\r\n    }\r\n    get length() {\r\n        return Math.sqrt(this.squaredLength);\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}