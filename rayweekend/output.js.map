{"version":3,"file":"","sourceRoot":"","sources":["drawing.js","index.js","misc.js","ray.js","vec.js"],"sourcesContent":["import { vec } from './vec';\nimport { ray } from './ray';\n\nexport function draw(scene, getColor) {\n\n    const started = new Date().getTime();\n\n    clearCanvas(scene.ctx, scene.dimu, scene.dimv);\n\n    // our camera\n    const origin = vec();\n\n    // lower left corner of the viewport in camera coordinate system\n    const lowerLeft = vec(-1, -1, -1);\n\n    // such that lowerLeft + vvec + vvec = vec(-lowerLeft.x, -lowerLeft.y, lowerLeft.z);\n    const uvec = vec(scene.userSettings.uvecX, 0, 0);\n    const vvec = vec(0, scene.userSettings.vvecY, 0);\n\n    for (let u = 0; u < scene.dimu; u += 1) {\n        for (let v = 0; v < scene.dimv; v += 1) {\n            const ur = u / scene.dimu; // [0;1)\n            const vr = v / scene.dimv; // [0;1)\n\n            // a ray from the camera to a pixel in the viewport\n            const tracedRay = ray(origin, lowerLeft.add(uvec.scale(ur), vvec.scale(vr)));\n\n            const color = getColor(tracedRay);\n\n            drawPixel(scene.ctx, u, v, color);\n        }\n    }\n\n    console.log(`drawing done: ${new Date().getTime() - started} ms`);\n}\n\nexport function clearCanvas(ctx, dimu, dimv) {\n    ctx.clearRect(0, 0, dimu, dimv);\n    ctx.fillStyle = '#cccccc';\n    ctx.fillRect(0, 0, dimu, dimv);\n}\n\nexport function drawPixel(ctx, x, y, color) {\n    // ((x + y) / 256) * (256 - 255.99) > y\n    // (x + y) * 0.01/256 > y\n    // x > 255.99y\n    //\n    // 256 * 0.53517 => 137.00352\n    // 255.99 * 0.53517 => 136.9981683\n    // 120.001 / 256 => 0.46875390625\n    // 0.46875390625 * 255.99 => 119.996312460938\n    const fill = \"rgb(\" +\n                    Math.floor(color[0] * 255.99) + \",\" +\n                    Math.floor(color[1] * 255.99) + \",\" +\n                    Math.floor(color[2] * 255.99) + \")\";\n\n    ctx.fillStyle = fill\n\n    //if (x % 10 === 0 && y % 10 === 0) {\n    //    console.log(JSON.stringify({ x, y, fill }));\n    //}\n    ctx.fillRect(x, y, 1, 1);\n}\n","// %USER_BACK%\\btsync\\books\\cg\\Ray Tracing in a Weekend.pdf\n\nimport { vec } from './vec';\nimport { ray } from './ray';\nimport { draw } from './drawing';\nimport { setupGui } from './misc';\n\nconst canvas = document.getElementById('canvas');\n\n// u/v - uniform coordinate system of the viewport\n// origin is top left, u goes left to right, v - top to bottom\n// corresponds to browser's x/y, but we're using x/y/z for camera coordinate system\n\nconst ctx = canvas.getContext('2d');\nconst userSettings = {\n    uvecX: { name: \"X\", initial: 2, min: -4, max: 4, step: 0.1 },\n    vvecY: { name: \"Y\", initial: 2, min: -2, max: 2, step: 0.1 },\n    radius: { name: \"radius\", initial: 0.2, min: 0, max: 4, step: 0.1 },\n};\n\nconst sphere = () => ({\n    type: \"sphere\",\n    center: vec(0, 0, -1),\n    radius: userSettings.radius\n});\n\nconst scene = {\n    dimu: 600,\n    dimv: 600,\n    objects: [sphere],\n    ctx,\n    userSettings\n}\n\n\ncanvas.width = scene.dimu;\ncanvas.height = scene.dimv;\n\nconst doDraw = () => draw(scene, getColor);\n\nsetupGui(scene.userSettings, doDraw);\n\nfunction intersectsSphere(tracedRay, sphere) {\n    const radius = sphere.radius;\n    const oc = tracedRay.origin.sub(sphere.center);\n    const a = tracedRay.direction.dot(tracedRay.direction);\n    const b = 2 * oc.dot(tracedRay.direction);\n    const c = oc.dot(oc) - sphere.radius * sphere.radius;\n    const disc = b * b - 4 * a * c;\n    return disc >= 0;\n}\n\nfunction getColor(tracedRay) {\n    for (const obj of scene.objects) {\n        const resolved = obj();\n        if (resolved.type === \"sphere\") {\n            if (intersectsSphere(tracedRay, resolved)) {\n                return vec(1, 0, 0);\n            }\n        }\n    }\n\n    // among all rays that hit the viewport at a given v', the one with the highest\n    // normalized abs(y) is the one with x = 0 (the one going directly towards the viewport)\n    // all vectors from the origin have the same non-normalized y (=v'), divided by a length\n    // >= sqrt(v'^2 + z^2), with equality only when x = 0\n    //\n    // imagine a cone with a vertex at the origin (i.e. rays with a given 'y') intersecting a\n    // plane (the viewport plane) - you get a hyperbola\n    //\n    // v' = y/sqrt(x^2 + y^2 + z'^2) (z' and v' are parameters)\n    // v'^2*z'^2 = y^2*(1-v'^2) - x^2 (which is a hyperbolic formula)\n    // y = +/- sqrt(param + x^2)/param => y has maximum abs when x = 0\n    //\n    // this is why the resulting gradient is dimmest in the middle and gets brighter at the sides\n    // (bottom half), or is brightest in the middle and dims towards the sides (top half)\n    // - points with equal lumosity are on a hyperbola with vertex in the vertical midline\n    // of the viewport\n    //\n    // among rays with x=0, the highest normalized y is the one hitting at the highest v, so\n    // the brightest place is the top center; analogously, the dimmest place is the bottom center\n    const unitDirection = tracedRay.direction.normalize();\n    const t = 0.5*(unitDirection.y + 1);\n    const color = vec(0, 0, 0).interpolate(vec(1, 1, 1), t);\n    return color;\n    // (square (abs(x - 0.5)))*sgn(x - 0.5) + 0.5 from 0 to 1\n//    if (color.r > 0.3 && color.r < 0.31) {\n//        return vec(1, 0, 0);\n//    } else if (color.r > 0.7 && color.r < 0.71) {\n//        return vec(0, 1, 0);\n//    } else if (color.r > 0.49 && color.r < 0.51) {\n//        return vec(1, 1, 1);\n//    } else if (color.r > 0.8 && color.r < 0.81) {\n//        return vec(0, 0, 1);\n//    }\n//    return vec();\n}\n\n\n\ndoDraw();","// from [x, r, e1] defines properties x => _x, r => _x, e1 => _x\nexport function synonymize(obj, synonyms) {\n    for (const synonymSet of synonyms) {\n        const main = synonymSet[0];\n        for (const other of synonymSet) {\n            Object.defineProperty(\n                obj,\n                other,\n                {\n                    get: function() {\n                        return this[\"_\" + main];\n                    }\n                });\n        }\n    }\n}\n\nexport function setupGui(userSettings, onChange) {\n\tvar gui = new dat.GUI();\n\n    var listen = ctrl => ctrl.onFinishChange(x => onChange);\n\n    for (const key of Object.keys(userSettings)) {\n        const userSetting = userSettings[key];\n        userSettings[key] = userSetting.initial\n        const step = userSetting.step || (userSettings.max - userSettings.min / 100);\n        const newSetting = gui.add(\n            userSettings,\n            key,\n            userSetting.min,\n            userSetting.max)\n            .step(step)\n            .name(userSetting.name || key);\n\n        listen(newSetting);\n    }\n}","import { synonymize } from './misc';\n\nconst rayProto = {};\nsynonymize(rayProto, [[\"direction\"], [\"origin\"]]);\nrayProto.toString = function() {\n    return JSON.stringify({ o: this.origin + \"\", d: this.direction + \"\" }).replace(/\"/g, \"\");\n}\n\nexport function ray(origin, direction) {\n    const toReturn = Object.create(rayProto);\n\n    toReturn._origin = origin;\n    toReturn._direction = direction;\n\n    return toReturn;\n}\n\n","import { synonymize } from './misc';\n\nconst vecProto = {};\n\nconst vectorSynonyms = [\n    ['x','r','0'],\n    ['y','g','1'],\n    ['z','b','2'],\n    ['w','a','3'],\n];\n\nsynonymize(vecProto, vectorSynonyms);\n\nvecProto.add = function() {\n    let toReturn = this;\n    for (const v2 of arguments) {\n        toReturn = vec(\n            toReturn.x + v2.x,\n            toReturn.y + v2.y,\n            toReturn.z + v2.z,\n            toReturn.w + v2.w);\n    }\n    return toReturn;\n};\n\nvecProto.scale = function(s) {\n    return vec(this.x * s, this.y * s, this.z * s, this.w * s);\n};\n\nvecProto.normalize = function() {\n    return this.scale(1 / this.length);\n};\n\nvecProto.sub = function(v2) {\n    return this.add(v2.neg());\n};\n\nvecProto.interpolate = function(v2, t) {\n    return this.scale(t).add(v2.scale(1 - t));\n};\n\nvecProto.neg = function() {\n    return this.scale(-1);\n//    howMany = typeof howMany === \"undefined\" ? 4 : howMany;\n//    return vec(\n//        howMany > 0 ? -this.x : this.x,\n//        howMany > 1 ? -this.y : this.y,\n//        howMany > 2 ? -this.z : this.z,\n//        howMany > 3 ? -this.w : this.w,\n//        );\n};\n\nvecProto.dot = function(v2) {\n    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;\n};\n\nvecProto.cross = function(v2) {\n    /*\n    yz - zy\n    -xz + zx\n    xy - yx\n    */\n    return vec(\n        this.y * v2.z - this.z * v2.y,\n        -this.x * v2.z + this.z * v2.x,\n        this.x * v2.y - this.y * v2.x,\n        this.w); // todo: 4d vector cross product\n};\nvecProto.toString = function() {\n    return JSON.stringify([\n            this.x.toFixed(2),\n            this.y.toFixed(2),\n            this.z.toFixed(2),\n            this.w.toFixed(2)])\n        .replace(/\"/g, \"\");\n};\n\nObject.defineProperty(\n    vecProto,\n    'squaredLength',\n    {\n        get: function() {\n            return Math.pow(this.x, 2) +\n                Math.pow(this.y, 2) +\n                Math.pow(this.z, 2) +\n                Math.pow(this.w, 2);\n            }\n    });\n\nObject.defineProperty(\n    vecProto,\n    'length',\n    {\n        get: function() {\n            return Math.sqrt(this.squaredLength)\n        }\n    });\n\nexport function vec(x, y, z, w) {\n    const toReturn = Object.create(vecProto);\n\n    toReturn._x = x || 0;\n    toReturn._y = y || 0;\n    toReturn._z = z || 0;\n    toReturn._w = w || 0;\n\n    return toReturn;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}